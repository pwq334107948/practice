Index: src/comp1110/ass2/Arboretum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package comp1110.ass2;\r\n\r\nimport java.util.*;\r\n\r\npublic class Arboretum {\r\n\r\n    /**\r\n     * A hiddenState string array is well-formed if it complies with the following rules:\r\n     * <p>\r\n     * hiddenState[0] - Deck\r\n     * A number of 2-character card substrings sorted alphanumerically as defined below\r\n     * For example: \"a3a8b5b6c2c7d1d3d7d8m1\"\r\n     * <p>\r\n     * hiddenState[1] - Player A's hand\r\n     * 0th character is 'A'\r\n     * Followed by 7, 8 or 9 2-character card substrings sorted alphanumerically.\r\n     * For example a full hand String might look like: \"Ab3b4c1j1m2m5m8\"\r\n     * <p>\r\n     * hiddenState[2] - Player B's hand\r\n     * 0th character is 'B'\r\n     * Followed by 7, 8 or 9 2-character _card_ substrings\r\n     * For example: \"Ba6b7b8c8d2j2j8\"\r\n     * <p>\r\n     * Where:\r\n     * \"card substring\" - A 2-character string that represents a single card.\r\n     * 0th character is 'a', 'b', 'c', 'd', 'j', or 'm' representing the card species.\r\n     * 1st character is a sequential digit from '1' to '8', representing the value of the card.\r\n     * For example: \"d7\"\r\n     * <p>\r\n     * \"alphanumerical(ly)\" - This means that cards are sorted first alphabetically and then numerically.\r\n     * For example, \"m2\" appears before \"m5\" because 2 < 5\r\n     * Whilst \"b4\" appears before \"c1\" because alphabetical ordering takes precedence over\r\n     * numerical ordering.\r\n     * <p>\r\n     * Exceptions:\r\n     * - If the deck is empty, hiddenState[0] will be the empty string \"\"\r\n     * - If a player's hand is empty, then the corresponding hiddenState[i] will contain only the player's ID.\r\n     * For example: if player A's hand is empty then hiddenState[1] will be \"A\" with no other characters.\r\n     *\r\n     * @param hiddenState the hidden state array.\r\n     * @return true if the hiddenState array is well-formed, false if it is not well-formed.\r\n     * @author Weiqiang PU\r\n     * TASK 3\r\n     */\r\n    public static boolean isHiddenStateWellFormed(String[] hiddenState) {\r\n        if (hiddenState == null || (hiddenState.length != 3 && hiddenState.length != 4 && hiddenState.length != 5)) {\r\n            return false;\r\n        } else {\r\n            String[][] a = getValueFromHidden(hiddenState); //Extract card from the given string\r\n            Arrays.sort(a[0]);\r\n            Arrays.sort(a[1]);\r\n            Arrays.sort(a[2]);\r\n            if (Arrays.deepEquals(a, getValueFromHidden(hiddenState))) { //Check whether the given String is alphanumerical by comparing sorted to unsorted String\r\n                //Check whether Deck、PlayerA、PlayerB meets the rules in turn\r\n                if (hiddenState[0].isEmpty() || hiddenState[0].matches(\"^([abcdjm][1-8])*$\")) {\r\n                    if (hiddenState[1].equals(\"A\") || hiddenState[1].matches(\"^A([abcdjm][1-8]){7,9}$\")) {\r\n                        return hiddenState[2].equals(\"B\") || hiddenState[2].matches(\"^B([abcdjm][1-8]){7,9}$\");\r\n                    } else return false;\r\n                } else return false;\r\n            } else return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * A sharedState string array is well-formed if it complies with the following rules:\r\n     * <p>\r\n     * sharedState[0] - a single character ID string, either \"A\" or \"B\" representing whose turn it is.\r\n     * sharedState[1] - Player A's arboretum\r\n     * 0th character is 'A'\r\n     * Followed by a number of 8-character _placement_ substrings as defined below that occur in\r\n     * the order they were played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Ab1C00C00a4N01C00c3C00E01c6N02C00m7N02W01m4N01E01a5N02E01a2S01E01\"\r\n     * <p>\r\n     * sharedState[2] - Player A's discard\r\n     * 0th character is 'A'\r\n     * Followed by a number of 2-character _card_ substrings that occur in the order they were\r\n     * played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Aa7c4d6\"\r\n     * <p>\r\n     * sharedState[3] - Player B's arboretum\r\n     * 0th character is 'B'\r\n     * Followed by a number of 8-character _placement_ substrings that occur in the order they\r\n     * were played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Bj5C00C00j6S01C00j7S02W01j4C00W01m6C00E01m3C00W02j3N01W01\"\r\n     * <p>\r\n     * sharedState[4] - Player B's discard\r\n     * 0th character is 'B'\r\n     * Followed by a number of 2-character _card_ substrings that occur in the order they were\r\n     * played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Bb2d4c5a1d5\"\r\n     * <p>\r\n     * Where: \"card substring\" and \"alphanumerical\" ordering are defined above in the javaDoc for\r\n     * isHiddenStateWellFormed and placement substrings are defined as follows:\r\n     * <p>\r\n     * \"placement substring\" - An 8-character string that represents a card placement in a player's arboretum.\r\n     * - 0th and 1st characters are a 2-character card substring\r\n     * - 2nd character is 'N' for North, 'S' for South, or 'C' for Centre representing the\r\n     * direction of this card relative to the first card played.\r\n     * - 3rd and 4th characters are a 2-digit number from \"00\" to \"99\" representing the distance\r\n     * from the first card played to this card, in the direction of the 2nd character.\r\n     * - 5th character is 'E' for East, 'W' for West, or 'C' for Centre representing the\r\n     * direction of this card relative to the first card played.\r\n     * - 6th and 7th characters are a 2-digit number =from \"00\" to \"99\" representing the distance\r\n     * from the first card played to this card, in the direction of the 3rd character.\r\n     * For example: \"a1C00C00b3N01C00\" says that card \"a1\" was played first and card \"b3\" was played\r\n     * one square north of the first card (which was \"a1\").\r\n     * <p>\r\n     * Exceptions:\r\n     * If a player's discard or arboretum are empty, (ie: there are no cards in them), then the corresponding string\r\n     * should contain only the player ID.\r\n     * For example:\r\n     * - If Player A's arboretum is empty, then sharedState[1] would be \"A\" with no other characters.\r\n     * - If Player B's discard is empty, then sharedState[4] would be \"B\" with no other characters.\r\n     *\r\n     * @param sharedState the shared state array.\r\n     * @return true if the sharedState array is well-formed, false if it is not well-formed.\r\n     * @author Weiqiang PU\r\n     * TASK 4\r\n     */\r\n    public static boolean isSharedStateWellFormed(String[] sharedState) {\r\n        if (sharedState == null || (sharedState.length != 5 && sharedState.length != 7 && sharedState.length != 9))\r\n            return false;\r\n        else {\r\n            //Check whether index 0 - 4 meets the rules in turn\r\n            if (sharedState[0].matches(\"^[ABCD]$\")) {\r\n                if (sharedState[1].matches(\"^A([abcdjm][1-8][CNS]\\\\d{2}[CEW]\\\\d{2})*$\")) {\r\n                    if (sharedState[2].matches(\"^A([abcdjm][1-8])*$\")) {\r\n                        if (sharedState[3].matches(\"B([abcdjm][1-8][CNS]\\\\d{2}[CEW]\\\\d{2})*$\")) {\r\n                            return sharedState[4].matches(\"^B([abcdjm][1-8])*$\");\r\n                        } else return false;\r\n                    } else return false;\r\n                } else return false;\r\n            } else return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a deck string, draw a random card from the deck.\r\n     * You may assume that the deck string is well-formed.\r\n     *\r\n     * @param deck the deck string.\r\n     * @return a random cardString from the deck. If the deck is empty, return the empty string \"\".\r\n     * TASK 5\r\n     */\r\n    public static String drawFromDeck(String deck) {\r\n        if (deck.length() == 0) {\r\n            return \"\";\r\n        } else {\r\n            //initialize a new cardSting list, draw a random card from the new array list\r\n            Random rand = new Random();\r\n            ArrayList<String> cardList = new ArrayList<>();\r\n            for (int i = 0; i < deck.length() - 1; i += 2) {\r\n                cardList.add(deck.substring(i, i + 2));\r\n            }\r\n            int num = rand.nextInt(cardList.size());\r\n            return cardList.get(num);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine whether this placement is valid for the current player. The \"Turn String\" determines who is making\r\n     * this placement.\r\n     * <p>\r\n     * A placement is valid if the following conditions are met:\r\n     * <p>\r\n     * - The card is placed adjacent to a card that is already placed, or is placed in the position \"C00C00\" if this is\r\n     * the first card placed.\r\n     * - The card does not share a location with another card that has been placed by this player.\r\n     * - The card being placed is currently in the hand of this player.\r\n     * - The hand of this player has exactly 9 cards in it.\r\n     * <p>\r\n     * You may assume that the inputs to this method are valid and/or well-formed.\r\n     *\r\n     * @param gameState the game state array\r\n     * @param placement the placement string of the card to be placed\r\n     * @return false if the placement is valid, false if it is not valid.\r\n     * TASK 7\r\n     */\r\n    public static boolean isPlacementValid(String[][] gameState, String placement) {\r\n        // check who is the current player and set corresponding index\r\n        int handIndex, arboretumIndex;\r\n        if (Objects.equals(gameState[0][0], \"A\")) {\r\n            handIndex = 1;\r\n            arboretumIndex = 1;\r\n        } else {\r\n            handIndex = 2;\r\n            arboretumIndex = 3;\r\n        }\r\n        // check if the player has the card\r\n        if (!gameState[1][handIndex].contains(placement.substring(0, 2))) return false;\r\n        // check if the player has 9 cards in hand\r\n        if (gameState[1][handIndex].length() != 19) return false;\r\n        // check first card placement\r\n        if (placement.substring(2).equals(\"C00C00\")) {\r\n            return gameState[0][arboretumIndex].length() == 1;\r\n        }\r\n        // check if the card is adjacent to another card\r\n        for (var i = 1; i < gameState[0][arboretumIndex].length(); i += 8) {\r\n            if (isAdjacent(placement.substring(2), gameState[0][arboretumIndex].substring(i + 2, i + 8))) {\r\n                // check if the card shares a location with others\r\n                if (!gameState[0][arboretumIndex].substring(i + 2, i + 8).equals(\r\n                        placement.substring(2))) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static boolean isAdjacent(String newPosition, String position) {\r\n        if (Objects.equals(newPosition, \"C00C00\") && (\r\n                Objects.equals(position, \"C00E01\") | Objects.equals(position, \"N01C00\")\r\n                        | Objects.equals(position, \"C00W01\") | Objects.equals(position, \"S01C00\"))\r\n        ) return true;\r\n        boolean vertical = newPosition.substring(0, 3).equals(position.substring(0, 3));\r\n        boolean horizontal = newPosition.substring(3).equals(position.substring(3));\r\n        if (horizontal && (newPosition.startsWith(\"00\", 1)) &&\r\n                (position.startsWith(\"N01\") | position.startsWith(\"S01\"))) return true;\r\n        if (vertical && (newPosition.substring(4).equals(\"00\")) &&\r\n                (position.substring(3).equals(\"W01\")\r\n                        | position.substring(3).equals(\"E01\"))) return true;\r\n        if ((newPosition.startsWith(\"01\", 1)) && (position.startsWith(\"00\", 1)) &&\r\n                horizontal) return true;\r\n        if ((newPosition.substring(4).equals(\"01\"))\r\n                && (position.substring(4).equals(\"00\")) && vertical) return true;\r\n        int horizontalDifference = Integer.parseInt(newPosition.substring(1, 3))\r\n                - Integer.parseInt(position.substring(1, 3));\r\n        int verticalDifference = Integer.parseInt(newPosition.substring(4))\r\n                - Integer.parseInt(position.substring(4));\r\n        return (newPosition.charAt(0) == position.charAt(0))\r\n                && (newPosition.charAt(3) == position.charAt(3))\r\n                && ((((horizontalDifference == 1) | (horizontalDifference == -1))\r\n                && (newPosition.substring(4).equals(position.substring(4))))\r\n                | (((verticalDifference == 1) | (verticalDifference == -1))\r\n                && (newPosition.substring(1, 3).equals(position.substring(1, 3)))));\r\n    }\r\n\r\n    /**\r\n     * Determine whether the given gameState is valid.\r\n     * A state is valid if the following conditions are met:\r\n     * <p>\r\n     * - There are exactly 48 cards in the game across the deck and each player's hand, arboretum and discard pile.\r\n     * - There are no duplicates of any cards\r\n     * - Every card in each player's arboretum is adjacent to at least one card played _before_ it.\r\n     * - The number of card's in player B's arboretum is equal to, or one less than the number of cards in player\r\n     * A's arboretum.\r\n     * - Each player may have 0 cards in hand only if all cards are in the deck.\r\n     * - Otherwise, a player has exactly 7 cards in their hand if it is not their turn.\r\n     * - If it is a player's turn, they may have 7, 8, or 9 cards in hard.\r\n     * - The number of cards in a player's discard pile is less than or equal to the number of cards in their arboretum.\r\n     * <p>\r\n     * You may assume that the gameState array is well-formed.\r\n     *\r\n     * @param gameState the game state array\r\n     * @return true if the gameState is valid, false if it is not valid.\r\n     * TASK 8\r\n     */\r\n    public static boolean isStateValid(String[][] gameState) {\r\n        // check 0 card in hand\r\n        if (gameState[1][1].length() - 1 == 0 | gameState[1][2].length() - 1 == 0) {\r\n            if (gameState[1][0].length() / 2 != 48) return false;\r\n        } else {\r\n            // check whose turn it is\r\n            if (Objects.equals(gameState[0][0], \"A\")) {\r\n                // check 7 or 8 or 9 cards in hand\r\n                if ((gameState[1][1].length() - 1) / 2 != 7 && (gameState[1][1].length() - 1) / 2 != 8\r\n                        && (gameState[1][1].length() - 1) / 2 != 9) return false;\r\n                // check exact 7 cards in hand\r\n                if ((gameState[1][2].length() - 1) / 2 != 7) return false;\r\n            } else {\r\n                if ((gameState[1][2].length() - 1) / 2 != 7 && (gameState[1][2].length() - 1) / 2 != 8\r\n                        && (gameState[1][2].length() - 1) / 2 != 9) return false;\r\n                if ((gameState[1][1].length() - 1) / 2 != 7) return false;\r\n            }\r\n        }\r\n        // check number of cards in players' arboretum\r\n        if ((gameState[0][3].length() - 1) / 8 > (gameState[0][1].length() - 1) / 8) return false;\r\n        // check number of cards in players' discard pile\r\n        if ((gameState[0][2].length() - 1) / 2 > (gameState[0][1].length() - 1) / 8) return false;\r\n        if ((gameState[0][4].length() - 1) / 2 > (gameState[0][3].length() - 1) / 8) return false;\r\n        // put all cards into one string\r\n        StringBuilder allCards = new StringBuilder(gameState[1][0] + gameState[1][1].substring(1) +\r\n                gameState[1][2].substring(1) + gameState[0][2].substring(1)\r\n                + gameState[0][4].substring(1));\r\n        for (var i = 1; i < gameState[0][1].length(); i += 8) {\r\n            allCards.append(gameState[0][1], i, i + 2);\r\n        }\r\n        for (var i = 1; i < gameState[0][3].length(); i += 8) {\r\n            allCards.append(gameState[0][3], i, i + 2);\r\n        }\r\n        // check exact 48 cards\r\n        if (allCards.length() / 2 != 48) return false;\r\n        // check no duplicates of any cards\r\n        ArrayList<String> cardsList = new ArrayList<>();\r\n        for (var i = 0; i < allCards.length(); i += 2) {\r\n            if (cardsList.contains(allCards.substring(i, i + 2))) {\r\n                return false;\r\n            } else {\r\n                cardsList.add(allCards.substring(i, i + 2));\r\n            }\r\n        }\r\n        // check adjacent cards in each player's arboretum\r\n        if (!checkBefore(gameState[0][1])) return false;\r\n        return checkBefore(gameState[0][3]);\r\n    }\r\n\r\n    public static boolean checkBefore(String arboretumString) {\r\n        ArrayList<String> arboretumList = new ArrayList<>();\r\n        for (var i = 1; i < arboretumString.length(); i += 8) {\r\n            arboretumList.add(arboretumString.substring(i + 2, i + 8));\r\n        }\r\n        if (arboretumList.size() == 1 && !Objects.equals(arboretumList.get(0), \"C00C00\")) return false;\r\n        while (arboretumList.size() > 1) {\r\n            boolean checkAdjacent = false;\r\n            for (var i : arboretumList) {\r\n                if (isAdjacent(arboretumList.get(arboretumList.size() - 1), i)) {\r\n                    checkAdjacent = true;\r\n                    arboretumList.remove(arboretumList.size() - 1);\r\n                    break;\r\n                }\r\n            }\r\n            if (!checkAdjacent) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Determine whether the given player has the right to score the given species. Note: This does not check whether\r\n     * a viable path exists. You may gain the right to score a species that you do not have a viable scoring path for.\r\n     * See \"Gaining the Right to Score\" in `README.md`.\r\n     * You may assume that the given gameState array is valid.\r\n     * <p>\r\n     * You may assume that the inputs to this method are valid and/or well-formed.\r\n     *\r\n     * @param gameState the game state array.\r\n     * @param player    the player attempting to score.\r\n     * @param species   the species that is being scored.\r\n     * @return true if the given player has the right to score this species, false if they do not have the right.\r\n     * TASK 9\r\n     */\r\n    public static boolean canScore(String[][] gameState, char player, char species) {\r\n        char playerOpponent = ' ';\r\n        if (player == 'A') {\r\n            playerOpponent = 'B';\r\n        } else if (player == 'B') {\r\n            playerOpponent = 'A';\r\n        }\r\n        int num = scoreFromHand(gameState, player, species);\r\n        int num_2 = scoreFromHand(gameState, playerOpponent, species);\r\n        //If a player has an \"8\" of a species in his hand and his opponent has a \"1\" of that species,\r\n        // then the value \"8\" is considered to be \"0\" for the purpose of determining who has the highest total.\r\n        if (storeFromHand(gameState, player).contains(species + \"8\") && storeFromHand(gameState, playerOpponent).contains(species + \"1\")) {\r\n            num -= 8;\r\n        } else if (storeFromHand(gameState, player).contains(species + \"1\") && storeFromHand(gameState, playerOpponent).contains(species + \"8\")) {\r\n            num_2 -= 8;\r\n        }\r\n        return num > num_2 || num == num_2;\r\n    }\r\n\r\n    public static ArrayList<String> storeFromHand(String[][] gameState, char player) {\r\n        //Draw the player's hand and store it in the ArrayList\r\n        String hand = \"\";\r\n        ArrayList<String> handCards = new ArrayList<>();\r\n        if (player == 'A') {\r\n            hand = gameState[1][1];\r\n        } else if (player == 'B') {\r\n            hand = gameState[1][2];\r\n        }\r\n        for (int i = 1; i < hand.length() - 1; i += 2) {\r\n            handCards.add(hand.substring(i, i + 2));\r\n        }\r\n        return handCards;\r\n    }\r\n\r\n    public static int scoreFromHand(String[][] gameState, char player, char species) {\r\n        //For a given specie, sum the values of such cards in the player's hand.\r\n        String hand = \"\";\r\n        if (player == 'A') {\r\n            hand = gameState[1][1];\r\n        } else if (player == 'B') {\r\n            hand = gameState[1][2];\r\n        }\r\n        int sum = 0;\r\n        for (int i = 1; i < hand.length(); i += 2) {\r\n            if (hand.charAt(i) == species) {\r\n                sum += Character.getNumericValue(hand.charAt(i + 1));\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * Find all the valid placements for the given card for the player whose turn it is.\r\n     * A placement is valid if it satisfies the following conditions:\r\n     * 1. The card is horizontally or vertically adjacent to at least one other placed card.\r\n     * 2. The card does not overlap with an already-placed card.\r\n     * <p>\r\n     * You may assume that the inputs to this method are valid and/or well-formed.\r\n     *\r\n     * @param gameState the game state array\r\n     * @param card      the card to play\r\n     * @return a set of valid card placement strings for the current player.\r\n     * TASK 10\r\n     */\r\n    public static Set<String> getAllValidPlacements(String[][] gameState, String card) {\r\n        Set<String> placementSet = new HashSet<>();\r\n        List<String> posList = new ArrayList<>();\r\n        int turn;\r\n        if (Objects.equals(gameState[0][0], \"A\")) {\r\n            turn = 1;\r\n        } else {\r\n            turn = 3;\r\n        }\r\n        if ((Objects.equals(gameState[0][0], \"A\") && gameState[0][turn].length() == 1)\r\n                | (Objects.equals(gameState[0][0], \"B\") && gameState[0][turn].length() == 1)) {\r\n            placementSet.add(card + \"C00C00\");\r\n            return placementSet;\r\n        }\r\n        for (int i = 1; i < gameState[0][turn].length(); i += 8) {\r\n            posList.add(gameState[0][turn].substring(i + 2, i + 8));\r\n        }\r\n        for (var i : posList) placementSet.addAll(findAdjacent(card, i));\r\n        for (var i : posList) placementSet.remove(card + i);\r\n        return placementSet;\r\n    }\r\n\r\n    public static Set<String> findAdjacent(String card, String posString) {\r\n        Set<String> placementSet = new HashSet<>();\r\n        Set<String> verticalSet = new HashSet<>();\r\n        Set<String> horizontalSet = new HashSet<>();\r\n        if (posString.startsWith(\"N01\") | posString.startsWith(\"S01\")) {\r\n            verticalSet.add(\"C00\");\r\n            verticalSet.add(posString.charAt(0) + \"02\");\r\n        } else if (posString.startsWith(\"C00\")) {\r\n            verticalSet.add(\"N01\");\r\n            verticalSet.add(\"S01\");\r\n        } else {\r\n            String v1 = String.valueOf(Integer.parseInt(posString.substring(1, 3)) - 1);\r\n            String v2 = String.valueOf(Integer.parseInt(posString.substring(1, 3)) + 1);\r\n            buildPosition(posString, verticalSet, v1, v2, 0);\r\n        }\r\n        if (posString.substring(3).equals(\"E01\") | posString.substring(3).equals(\"W01\")) {\r\n            horizontalSet.add(\"C00\");\r\n            horizontalSet.add(posString.charAt(3) + \"02\");\r\n        } else if (posString.substring(3).equals(\"C00\")) {\r\n            horizontalSet.add(\"E01\");\r\n            horizontalSet.add(\"W01\");\r\n        } else {\r\n            String h1 = String.valueOf(Integer.parseInt(posString.substring(4)) - 1);\r\n            String h2 = String.valueOf(Integer.parseInt(posString.substring(4)) + 1);\r\n            buildPosition(posString, horizontalSet, h1, h2, 3);\r\n        }\r\n        for (var i : verticalSet) placementSet.add(card + i + posString.substring(3));\r\n        for (var i : horizontalSet) placementSet.add(card + posString.substring(0, 3) + i);\r\n        return placementSet;\r\n    }\r\n\r\n    public static void buildPosition(String posString, Set<String> stringSet, String string1,\r\n                                     String string2, Integer index) {\r\n        if (string1.length() == 1) {\r\n            stringSet.add(posString.charAt(index) + \"0\" + string1);\r\n        } else {\r\n            stringSet.add(posString.charAt(index) + string1);\r\n        }\r\n        if (string2.length() == 1) {\r\n            stringSet.add(posString.charAt(index) + \"0\" + string2);\r\n        } else {\r\n            stringSet.add(posString.charAt(index) + string2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find all viable scoring paths for the given player and the given species if this player has the right to\r\n     * score this species.\r\n     * <p>\r\n     * A \"scoring path\" is a non-zero number of card substrings in order from starting card to ending card.\r\n     * For example: \"a1a3b6c7a8\" is a path of length 5 starting at \"a1\" and ending at \"a8\".\r\n     * <p>\r\n     * A path is viable if the following conditions are met:\r\n     * 1. The player has the right to score the given species.\r\n     * 2. Each card along the path is orthogonally adjacent to the previous card.\r\n     * 3. Each card has value greater than the previous card.\r\n     * 4. The path begins with the specified species.\r\n     * 5. The path ends with the specified species.\r\n     * <p>\r\n     * You may assume that the inputs to this method are valid and/or well-formed.\r\n     *\r\n     * @param gameState the game state array\r\n     * @param player    the given player\r\n     * @param species   the species the path must start and end with.\r\n     * @return a set of all viable scoring paths if this player has the right to score this species, or null if this\r\n     * player does not have the right to score this species. If the player has no viable scoring paths (but has the\r\n     * right to score this species), return the empty Set.\r\n     * TASK 12\r\n     */\r\n    public static Set<String> getAllViablePaths(String[][] gameState, char player, char species) {\r\n        // return null if the player does not have the right to score this species\r\n        if (!canScore(gameState, player, species)) return null;\r\n        // distinguish player and put arboretum into one string\r\n        var allCards = player == 'A' ? gameState[0][1] : gameState[0][3];\r\n        // put all cards and selected species into two sets\r\n        Set<String> cardsSet = new HashSet<>();\r\n        Set<String> speciesSet = new HashSet<>();\r\n        for (int i = 1; i < allCards.length(); i += 8) {\r\n            cardsSet.add(allCards.substring(i, i + 8));\r\n            if (allCards.charAt(i) == species) speciesSet.add(allCards.substring(i, i + 8));\r\n        }\r\n        // record viable paths\r\n        Set<String> placementOutput = new HashSet<>();\r\n        Set<String> cardOutput = new HashSet<>();\r\n        while (!pathFinder(speciesSet, cardsSet).isEmpty()) {\r\n            var resultSet = pathFinder(speciesSet, cardsSet);\r\n            for (var i : resultSet) {\r\n                if (i.length() > 8) {\r\n                    if (i.charAt(0) == i.charAt(i.length() - 8)) placementOutput.add(i);\r\n                }\r\n                speciesSet = resultSet;\r\n            }\r\n        }\r\n        // change the output format from \"a2S01E01a3C00E01\" to \"a2a3\"\r\n        for (var i : placementOutput) {\r\n            StringBuilder tempCard = new StringBuilder();\r\n            for (int j = 0; j < i.length(); j += 8) {\r\n                tempCard.append(i, j, j + 2);\r\n            }\r\n            cardOutput.add(tempCard.toString());\r\n        }\r\n        return cardOutput;\r\n    }\r\n\r\n    /**\r\n     * Generate one-step-further path based on the given path.\r\n     * <p>\r\n     * This is a helper method made for getAllViablePaths().\r\n     *\r\n     * @param speciesSet a set of cards with selected species\r\n     * @param cardsSet   a set of all cards in the arboretum\r\n     * @return a set of one-step-further path\r\n     * TASK 12\r\n     */\r\n    public static Set<String> pathFinder(Set<String> speciesSet, Set<String> cardsSet) {\r\n        Set<String> resultSet = new HashSet<>();\r\n        for (var specie : speciesSet) {\r\n            // get the last card of current path\r\n            String lastOfSpecie = specie.substring(specie.length() - 8);\r\n            for (var neighbor : findAdjacent(lastOfSpecie.substring(0, 2), lastOfSpecie.substring(2))) {\r\n                for (var card : cardsSet) {\r\n                    // check if the card has neighbor in current arboretum\r\n                    if (card.substring(2).equals(neighbor.substring(2))) {\r\n                        // check if the card has value greater than the previous card\r\n                        if (card.charAt(1) > lastOfSpecie.charAt(1)) resultSet.add(specie + card);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return resultSet;\r\n    }\r\n\r\n    /**\r\n     * Find the highest score of the viable paths for the given player and species.\r\n     * <p>\r\n     * You may assume that the inputs to this method are valid and/or well-formed.\r\n     *\r\n     * @param gameState the game state array\r\n     * @param player    the given player\r\n     * @param species   the species to score\r\n     * @return the score of the highest scoring viable path for this player and species.\r\n     * If this player does not have the right to score this species, return -1.\r\n     * If this player has the right to score this species but there is no viable scoring path, return 0.\r\n     * TASK 13\r\n     */\r\n    public static int getHighestViablePathScore(String[][] gameState, char player, char species) {\r\n        // check can score or not\r\n        if (!canScore(gameState, player, species)) return -1;\r\n        // check if there is viable scoring path\r\n        if (Objects.requireNonNull(getAllViablePaths(gameState, player, species)).isEmpty()) return 0;\r\n        var allPaths = getAllViablePaths(gameState, player, species);\r\n        List<Integer> scoreList = new ArrayList<>();\r\n\r\n        assert allPaths != null;\r\n        for (var i : allPaths) {\r\n            int score = 0;\r\n            int cardNum = i.length() / 2;\r\n            // 1 point for each card\r\n            score += cardNum;\r\n            // additional point for same species\r\n            boolean checkSame = true;\r\n            for (int j = 0; j < i.length(); j += 2) {\r\n                if (i.charAt(j) != species) {\r\n                    checkSame = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (cardNum >= 4 && checkSame) score += cardNum;\r\n            // additional point if the path begins with \"1\"\r\n            if (i.charAt(1) == '1') score += 1;\r\n            // additional points if the path ends with \"8\"\r\n            if (i.charAt(i.length() - 1) == '8') score += 2;\r\n            // store in list\r\n            scoreList.add(score);\r\n        }\r\n        // get the highest score\r\n        int highest = scoreList.get(0);\r\n        for (var i : scoreList) {\r\n            if (i > highest) highest = i;\r\n        }\r\n        return highest;\r\n    }\r\n\r\n    /**\r\n     * When the game is ended, calculate the player's total score.\r\n     * <p>\r\n     *\r\n     * @param gameState the game state array\r\n     * @param player    the given player\r\n     * @return Total score of all viable paths in this player's Arboretum that have scoring rights.\r\n     * If this player does not have the right to score this species, return -1.\r\n     * If this player has the right to score this species but there is no viable scoring path, return 0.\r\n     * The above two cases are not counted in the total score.\r\n     * @author Hanqin Liu\r\n     */\r\n    public static int getTotalViablePathScore(String[][] gameState, char player) {\r\n        int score = 0;\r\n        char[] species = {'a', 'b', 'c', 'd', 'j', 'm'};\r\n        for (char c : species) {\r\n            if (getHighestViablePathScore(gameState, player, c) > 0) {\r\n                score += getHighestViablePathScore(gameState, player, c);\r\n            }\r\n        }\r\n        return score;\r\n    }\r\n\r\n    /**\r\n     * Find the winner of the game.\r\n     * <p>\r\n     *\r\n     * @param gameState the game state array\r\n     * @return Returns a string that outputs the state at the end of the game.\r\n     * @author Hanqin Liu\r\n     */\r\n    public static String getWinner(String[][] gameState){\r\n        HashSet<Object> speciesSetA = new HashSet<>();\r\n        HashSet<Object> speciesSetB = new HashSet<>();\r\n        if(getTotalViablePathScore(gameState,'A') > getTotalViablePathScore(gameState,'B')){\r\n            return \"The winner is player A!\";\r\n        }else if (getTotalViablePathScore(gameState,'A') < getTotalViablePathScore(gameState,'B')){\r\n            return \"The winner is player B!\";\r\n        }else {\r\n\r\n            for(int i = 1; i < gameState[0][1].length(); i += 8){\r\n                speciesSetA.add(gameState[0][1].charAt(i));\r\n            }\r\n            for(int i = 1; i < gameState[0][3].length(); i += 8){\r\n                speciesSetB.add(gameState[0][3].charAt(i));\r\n            }\r\n            if(speciesSetA.size() > speciesSetB.size()){\r\n                return \"The winner is player A!\";\r\n            }else if(speciesSetA.size() < speciesSetB.size()){\r\n                return \"The winner is player B!\";\r\n            }else {\r\n                return \"The game is a tie!\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * AI Part 1:\r\n     * Decide whether to draw a card from the deck or a discard pile.\r\n     * Note: This method only returns the choice, it does not update the game state.\r\n     * If you wish to draw a card from the deck, return \"D\".\r\n     * If you wish to draw a card from a discard pile, return the cardstring of the (top) card you wish to draw.\r\n     * You may count the number of cards in a players' hand to determine whether this is their first or final draw\r\n     * for the turn.\r\n     * <p>\r\n     * Note: You may only draw the top card of a players discard pile. ie: The last card that was added to that pile.\r\n     * Note: There must be cards in the deck (or alternatively discard) to draw from the deck (or discard) respectively.\r\n     * <p>\r\n     * You may assume that the inputs to this method are valid and/or well-formed.\r\n     *\r\n     * @param gameState the game state array\r\n     * @return \"D\" if you wish to draw from the deck, or the cardstring of the card you wish to draw from a discard\r\n     * pile.\r\n     * TASK 14\r\n     */\r\n    public static String chooseDrawLocation(String[][] gameState) {\r\n        return null;\r\n        // FIXME TASK 14\r\n    }\r\n\r\n\r\n    /**\r\n     * AI Part 2:\r\n     * Generate a moveString array for the player whose turn it is.\r\n     * <p>\r\n     * A moveString array consists of two parts;\r\n     * moveString[0] is the valid card _placement_ string for the card you wish to place.\r\n     * moveString[1] is the cardstring of the card you wish to discard.\r\n     * <p>\r\n     * For example: If I want to play card \"a1\" in location \"N01E02\" and discard card \"b4\" then my moveString[] would\r\n     * be as follows:\r\n     * moveString[0] = \"a1N01E02\"\r\n     * moveString[1] = \"b4\"\r\n     * <p>\r\n     * You may assume that the inputs to this method are valid and/or well-formed.\r\n     *\r\n     * @param gameState the game state array\r\n     * @return a valid move for this player.\r\n     * TASK 15\r\n     */\r\n    public static String[] generateMove(String[][] gameState) {\r\n        return null;\r\n        // FIXME TASK 15\r\n    }\r\n\r\n    /**\r\n     * Extracting deck and hand card value from given string\r\n     *\r\n     * @param gameStatePiece the game state array\r\n     * @return an array of array that stores card value\r\n     * @author Weiqiang PU\r\n     */\r\n    public static String[][] getValueFromHidden(String[] gameStatePiece) {\r\n        String[][] getValueFromHidden = new String[gameStatePiece.length][];\r\n        for (int a = 0; a < gameStatePiece.length; a++) { //extract card substring\r\n            ArrayList<String> getState = new ArrayList<>();\r\n            for (int b = a == 0 ? 0 : 1; b < gameStatePiece[a].length() - 1; b += 2) {\r\n                getState.add(gameStatePiece[a].substring(b, b + 2));\r\n            }\r\n            getValueFromHidden[a] = getState.toArray(new String[0]);\r\n        }\r\n        return getValueFromHidden;\r\n    }\r\n\r\n    /**\r\n     * Extracting turnID, player's arboretum and discard from the given string\r\n     * <p>\r\n     * sharedState[0] - a single character ID string, either \"A\" or \"B\" representing whose turn it is.\r\n     * <p>\r\n     * sharedState[1] - Player A's arboretum\r\n     * 0th character is 'A'\r\n     * Followed by a number of 8-character _placement_ substrings as defined below that occur in the order they were played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Ab1C00C00a4N01C00c3C00E01c6N02C00m7N02W01m4N01E01a5N02E01a2S01E01\"\r\n     * <p>\r\n     * sharedState[2] - Player A's discard\r\n     * 0th character is 'A'\r\n     * Followed by a number of 2-character _card_ substrings that occur in the order they were played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Aa7c4d6\"\r\n     * <p>\r\n     * sharedState[3] - Player B's arboretum\r\n     * 0th character is 'B'\r\n     * Followed by a number of 8-character _placement_ substrings that occur in the order they were played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Bj5C00C00j6S01C00j7S02W01j4C00W01m6C00E01m3C00W02j3N01W01\"\r\n     * <p>\r\n     * sharedState[4] - Player B's discard\r\n     * 0th character is 'B'\r\n     * Followed by a number of 2-character _card_ substrings that occur in the order they were played. Note: these are NOT sorted alphanumerically.\r\n     * For example: \"Bb2d4c5a1d5\"\r\n     * <p>\r\n     * For example:\r\n     * gameStatePiece = {\"A\",\r\n     * \"Ab1C00C00a4N01C00c3C00E01c6N02C00m7N02W01m4N01E01a5N02E01a2S01E01c8N02W02c1S01C00b6N03E01m8N03W01m1S02E01\", \"Aa3\",\r\n     * \"Bj5C00C00j6S01C00j7S01W01j4C00W01m6C00E01m3C00W02j3N01W01d2N02W01d7S02C00b8S02E01b3N01C00d1N03W01d8S03C00\", \"B\"}\r\n     * <p>\r\n     * getValueFromShared = {{\"A\"},\r\n     * {\"b1\",\"C00\",\"C00\",\"a4\",\"N01“,”C00“,”c3“,”C00“,”E01“,”c6“,”N02\",\"C00\",\"m7\",\"N02\",\"W01\",\"m4\",\"N01\",\"E01\",\"a5\",\"N02\",\"E01\",\"a2\",\"S01\",\"E01\",\"c8\",\"N02\",\"W02\",\"c1\",\"S01\",\"C00\",\"b6\",\"N03\",\"E01\",\"m8\",\"N03\",\"W01\",\"m1\",\"S02\",\"E01\"},\r\n     * {\"a3\"},\r\n     * {\"j5\",\"C00\",\"C00\",\"j6\",\"S01\",\"C00\",\"j7\",\"S01\",\"W01\",\"j4\",\"C00\",\"W01\",\"m6\",\"C00\",\"E01\",\"m3\",\"C00\",\"W02\",\"j3\",\"N01\",\"W01\",\"d2\",\"N02\",\"W01\",\"d7\",\"S02\",\"C00\",\"b8\",\"S02\",\"E01\",\"b3\",\"N01\",\"C00\",\"d1\",\"N03\",\"W01\",\"d8\",\"S03\",\"C00\"},\r\n     * {\"\"}}\r\n     *\r\n     * @param gameStatePiece the game state array\r\n     * @return an array of array that stores card value\r\n     * @author Weiqiang PU\r\n     */\r\n    public static String[][] getValueFromShared(String[] gameStatePiece) {\r\n        String[][] getValueFromShared = new String[gameStatePiece.length][];\r\n        getValueFromShared[0] = gameStatePiece[0].isBlank() ? new String[0] : new String[]{gameStatePiece[0].substring(0, 1)}; //get turnID\r\n        for (int a = 2; a <= gameStatePiece.length - 1; a += 2) { //extract discard card\r\n            ArrayList<String> getState = new ArrayList<>();\r\n            for (int b = 1; b < gameStatePiece[a].length() - 1; b += 2) {\r\n                getState.add(gameStatePiece[a].substring(b, b + 2));\r\n            }\r\n            getValueFromShared[a] = getState.toArray(new String[0]);\r\n        }\r\n        for (int c = 1; c < gameStatePiece.length - 1; c += 2) { //extract arboretum and direction\r\n            ArrayList<String> getState = new ArrayList<>();\r\n            for (int d = 1; d < gameStatePiece[c].length() - 7; d += 8) {\r\n                getState.add(gameStatePiece[c].substring(d, d + 2)); //tree piece and value\r\n                getState.add(gameStatePiece[c].substring(d + 2, d + 5)); //direction1\r\n                getState.add(gameStatePiece[c].substring(d + 5, d + 8)); //direction2\r\n            }\r\n            getValueFromShared[c] = getState.toArray(new String[0]);\r\n        }\r\n        return getValueFromShared;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/comp1110/ass2/Arboretum.java b/src/comp1110/ass2/Arboretum.java
--- a/src/comp1110/ass2/Arboretum.java	
+++ b/src/comp1110/ass2/Arboretum.java	
@@ -637,26 +637,26 @@
      * @return Returns a string that outputs the state at the end of the game.
      * @author Hanqin Liu
      */
-    public static String getWinner(String[][] gameState){
+    public static String getWinner(String[][] gameState) {
         HashSet<Object> speciesSetA = new HashSet<>();
         HashSet<Object> speciesSetB = new HashSet<>();
-        if(getTotalViablePathScore(gameState,'A') > getTotalViablePathScore(gameState,'B')){
+        if (getTotalViablePathScore(gameState, 'A') > getTotalViablePathScore(gameState, 'B')) {
             return "The winner is player A!";
-        }else if (getTotalViablePathScore(gameState,'A') < getTotalViablePathScore(gameState,'B')){
+        } else if (getTotalViablePathScore(gameState, 'A') < getTotalViablePathScore(gameState, 'B')) {
             return "The winner is player B!";
-        }else {
+        } else {
 
-            for(int i = 1; i < gameState[0][1].length(); i += 8){
+            for (int i = 1; i < gameState[0][1].length(); i += 8) {
                 speciesSetA.add(gameState[0][1].charAt(i));
             }
-            for(int i = 1; i < gameState[0][3].length(); i += 8){
+            for (int i = 1; i < gameState[0][3].length(); i += 8) {
                 speciesSetB.add(gameState[0][3].charAt(i));
             }
-            if(speciesSetA.size() > speciesSetB.size()){
+            if (speciesSetA.size() > speciesSetB.size()) {
                 return "The winner is player A!";
-            }else if(speciesSetA.size() < speciesSetB.size()){
+            } else if (speciesSetA.size() < speciesSetB.size()) {
                 return "The winner is player B!";
-            }else {
+            } else {
                 return "The game is a tie!";
             }
         }
@@ -682,6 +682,16 @@
      * TASK 14
      */
     public static String chooseDrawLocation(String[][] gameState) {
+        switch ((int) (Math.random() * 10 % 3)) {
+            case 0 -> {
+                if (gameState[1][0] != null && gameState[1][0].length() != 0) return "D";
+                else chooseDrawLocation(gameState);
+            }
+            case 1 -> {
+
+            }
+        }
+
         return null;
         // FIXME TASK 14
     }
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_17\" project-jdk-name=\"17\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	
+++ b/.idea/misc.xml	
@@ -3,4 +3,9 @@
   <component name="ProjectRootManager" version="2" languageLevel="JDK_17" project-jdk-name="17" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
+  <component name="SwUserDefinedSpecifications">
+    <option name="specTypeByUrl">
+      <map />
+    </option>
+  </component>
 </project>
\ No newline at end of file
