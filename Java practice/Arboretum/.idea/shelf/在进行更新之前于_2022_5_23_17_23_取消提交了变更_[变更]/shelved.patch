Index: src/comp1110/ass2/gui/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package comp1110.ass2.gui;\r\n\r\nimport comp1110.ass2.Arboretum;\r\nimport javafx.application.Application;\r\nimport javafx.geometry.Point2D;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Group;\r\nimport javafx.scene.Node;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.control.Label;\r\nimport javafx.scene.effect.DropShadow;\r\nimport javafx.scene.layout.GridPane;\r\nimport javafx.scene.layout.HBox;\r\nimport javafx.scene.layout.VBox;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.transform.NonInvertibleTransformException;\r\nimport javafx.stage.Modality;\r\nimport javafx.stage.Stage;\r\n\r\nimport java.util.*;\r\n\r\nimport static java.lang.Math.sqrt;\r\n\r\npublic class Game extends Application {\r\n    /* board layout */\r\n    private static final int BOARD_WIDTH = 1200;\r\n    private static final int BOARD_HEIGHT = 700;\r\n    private final double WINDOW_XOFFSET = 15.0;\r\n    private final double WINDOW_YOFFSET = 16.6;\r\n    private final int CARD_WIDTH = 76;\r\n    private final int CARD_HEIGHT = 120;\r\n    private Group root = new Group();\r\n    private Scene scene = new Scene(root, BOARD_WIDTH, BOARD_HEIGHT);\r\n    private final Button deckButton = new Button(\"\", new Card(\"00\"));\r\n    private final Button playerADiscardButton = new Button();\r\n    private final Button playerBDiscardButton = new Button();\r\n    private final HBox playerAHandPane = new HBox();\r\n    private final HBox playerBHandPane = new HBox();\r\n    private GridPane playerAArboretumPane = new GridPane();\r\n    private GridPane playerBArboretumPane = new GridPane();\r\n    private String[][] gameState = new String[][]{{\"A\", \"A\", \"A\", \"B\", \"B\"}, {\"a1a2a3a4a5a6a7a8b1b2b3b4b5b6b7b8c1c2c3c4c5c6c7c8d1d2d3d4d5d6d7d8j1j2j3j4j5j6j7j8m1m2m3m4m5m6m7m8\", \"A\", \"B\"}};\r\n    private int drawCount;\r\n    private boolean havePlaced;\r\n    private boolean haveDiscarded;\r\n    private boolean haveAI;\r\n    private PositionCard highlightedCard;\r\n\r\n    private double ax, ay, bx, by;\r\n    private final Set<Node> highlightedPane = new HashSet<>();\r\n\r\n    @Override\r\n    public void start(Stage stage) {\r\n        //initialize the position of each part\r\n        displayStart();\r\n        initializeBoardPosition();\r\n\r\n        deckButton.setOnMouseClicked(event -> {\r\n            if (drawCount < 2 && gameState[1][0].length() > 0) {\r\n                drawFromDeck();\r\n            }\r\n\r\n        });\r\n        playerADiscardButton.setOnMouseClicked(event -> {\r\n            if (drawCount < 2 && gameState[0][2].length() > 1) {\r\n                drawFromDiscard(2);\r\n            }\r\n        });\r\n        playerBDiscardButton.setOnMouseClicked(event -> {\r\n            if (drawCount < 2 && gameState[0][4].length() > 1) {\r\n                drawFromDiscard(4);\r\n            }\r\n        });\r\n\r\n        stage.setTitle(\"Arboretum\");\r\n        stage.setScene(scene);\r\n        stage.show();\r\n    }\r\n\r\n    /**\r\n     * initialize the game state\r\n     * fix the position of each part, including deck, hand, arboretum and discard pile\r\n     *\r\n     * @author Weiqiang PU\r\n     * @author Ziyao Jin\r\n     */\r\n    private void initializeBoardPosition() {\r\n        root.getChildren().clear();\r\n        //initialize hand cards\r\n        for (int count = 0; count < 7; count++) {\r\n            ArrayList<String> cardList = new ArrayList<>(Arrays.asList(Arboretum.getValueFromHidden(gameState[1])[0]));\r\n            StringBuilder tempDeck = new StringBuilder(gameState[1][0]);\r\n            for (int player = 1; player < 3; player++) {\r\n                String drawnCard = cardList.get((int) (Math.random() * cardList.size())); //draw card randomly\r\n                cardList.remove(drawnCard);\r\n                tempDeck.delete(tempDeck.indexOf(drawnCard), tempDeck.indexOf(drawnCard) + 2); //delete the drawn card from the deck\r\n                gameState[1][player] += drawnCard;\r\n            }\r\n            gameState[1][0] = tempDeck.toString();\r\n        }\r\n        //alphabetize hand\r\n        for (int player = 1; player < 3; player++) {\r\n            ArrayList<String> handStrList = new ArrayList<>(Arrays.asList(Arboretum.getValueFromHidden(gameState[1])[player]));\r\n            Collections.sort(handStrList);\r\n            StringBuilder tempHand = new StringBuilder(String.valueOf((char) (player + 64)));\r\n            for (String i : handStrList) {\r\n                tempHand.append(i);\r\n            }\r\n            gameState[1][player] = tempHand.toString();\r\n        }\r\n\r\n        Label deckLabel = new Label(\"Deck\");\r\n        deckLabel.setLayoutX((double) (BOARD_WIDTH + CARD_WIDTH) / 2 + WINDOW_XOFFSET);\r\n        deckLabel.setLayoutY((double) BOARD_HEIGHT / 2);\r\n        deckButton.setLayoutX((double) (BOARD_WIDTH - CARD_WIDTH) / 2);\r\n        deckButton.setLayoutY((double) (BOARD_HEIGHT - CARD_HEIGHT) / 2);\r\n\r\n        playerAHandPane.setLayoutX(WINDOW_XOFFSET);\r\n        playerAHandPane.setLayoutY(BOARD_HEIGHT - WINDOW_YOFFSET - CARD_HEIGHT);\r\n        playerAHandPane.setPrefSize(CARD_WIDTH * 9, CARD_HEIGHT);\r\n        playerAHandPane.setAlignment(Pos.CENTER);\r\n        Label playerAHandLabel = new Label(\"PlayerA Hand\");\r\n        playerAHandLabel.setLayoutX(WINDOW_XOFFSET + CARD_WIDTH * 3.5);\r\n        playerAHandLabel.setLayoutY(BOARD_HEIGHT - WINDOW_YOFFSET);\r\n\r\n        playerBHandPane.setLayoutX(BOARD_WIDTH - WINDOW_XOFFSET - CARD_WIDTH * 9);\r\n        playerBHandPane.setLayoutY(WINDOW_YOFFSET);\r\n        playerBHandPane.setPrefSize(CARD_WIDTH * 9, CARD_HEIGHT);\r\n        playerBHandPane.setAlignment(Pos.CENTER);\r\n        Label playerBHandLabel = new Label(\"PlayerB Hand\");\r\n        playerBHandLabel.setLayoutX(BOARD_WIDTH - WINDOW_XOFFSET - CARD_WIDTH * 5);\r\n\r\n        playerADiscardButton.setLayoutX((double) (BOARD_WIDTH - CARD_WIDTH) / 2);\r\n        playerADiscardButton.setLayoutY((double) (BOARD_HEIGHT - CARD_HEIGHT) / 2 + CARD_HEIGHT + WINDOW_YOFFSET);\r\n        playerADiscardButton.setPrefSize(CARD_WIDTH, CARD_HEIGHT);\r\n        Label playerADiscardLabel = new Label(\"PlayerA Discard\");\r\n        playerADiscardLabel.setLayoutX((double) (BOARD_WIDTH - CARD_WIDTH) / 2);\r\n        playerADiscardLabel.setLayoutY((double) BOARD_HEIGHT / 2 + WINDOW_YOFFSET + CARD_HEIGHT * 1.5);\r\n\r\n        playerBDiscardButton.setLayoutX((double) (BOARD_WIDTH - CARD_WIDTH) / 2);\r\n        playerBDiscardButton.setLayoutY((double) (BOARD_HEIGHT - CARD_HEIGHT) / 2 - CARD_HEIGHT - WINDOW_YOFFSET);\r\n        playerBDiscardButton.setPrefSize(CARD_WIDTH, CARD_HEIGHT);\r\n        Label playerBDiscardLabel = new Label(\"PlayerB Discard\");\r\n        playerBDiscardLabel.setLayoutX((double) (BOARD_WIDTH - CARD_WIDTH) / 2);\r\n        playerBDiscardLabel.setLayoutY((double) BOARD_HEIGHT / 2 - WINDOW_YOFFSET * 2 - CARD_HEIGHT * 1.5);\r\n\r\n        playerAArboretumPane.setLayoutX(WINDOW_XOFFSET);\r\n        playerAArboretumPane.setLayoutY(WINDOW_YOFFSET);\r\n        playerAArboretumPane.setPrefSize(BOARD_WIDTH - WINDOW_XOFFSET * 3 - CARD_WIDTH * 9, BOARD_HEIGHT - WINDOW_YOFFSET * 3 - CARD_HEIGHT);\r\n        playerAArboretumPane.setAlignment(Pos.CENTER);\r\n        Label playerAArboretumLabel = new Label(\"PlayerA Arboretum\");\r\n        playerAArboretumLabel.setLayoutX(WINDOW_XOFFSET + CARD_WIDTH * 2);\r\n\r\n        playerBArboretumPane.setLayoutX(WINDOW_XOFFSET * 2 + CARD_WIDTH * 9);\r\n        playerBArboretumPane.setLayoutY(WINDOW_YOFFSET * 2 + CARD_HEIGHT);\r\n        playerBArboretumPane.setPrefSize(BOARD_WIDTH - WINDOW_XOFFSET * 3 - CARD_WIDTH * 9, BOARD_HEIGHT - WINDOW_YOFFSET * 3 - CARD_HEIGHT);\r\n        playerBArboretumPane.setAlignment(Pos.CENTER);\r\n        Label playerBArboretumLabel = new Label(\"PlayerB Arboretum\");\r\n        playerBArboretumLabel.setLayoutX(BOARD_WIDTH - WINDOW_XOFFSET - CARD_WIDTH * 4);\r\n        playerBArboretumLabel.setLayoutY(BOARD_HEIGHT - WINDOW_YOFFSET);\r\n\r\n        deckButton.setStyle(\"-fx-background-color: transparent\");\r\n        playerADiscardButton.setStyle(\"-fx-background-color: transparent\");\r\n        playerBDiscardButton.setStyle(\"-fx-background-color: transparent\");\r\n        playerAHandPane.setStyle(\"-fx-border-color: #6d8a8a\");\r\n        playerBHandPane.setStyle(\"-fx-border-color: #6d8a8a\");\r\n        playerAArboretumPane.setStyle(\"-fx-border-color: #6d8a8a\");\r\n        playerBArboretumPane.setStyle(\"-fx-border-color: #6d8a8a\");\r\n\r\n        root.getChildren().addAll(playerAArboretumPane, playerBArboretumPane,\r\n                playerADiscardButton, playerBDiscardButton, deckButton, deckLabel, playerAHandLabel, playerBHandLabel,\r\n                playerADiscardLabel, playerBDiscardLabel, playerAArboretumLabel, playerBArboretumLabel, playerAHandPane, playerBHandPane);\r\n\r\n        ax = playerAArboretumPane.getBoundsInParent().getMinX();\r\n        ay = playerAArboretumPane.getBoundsInParent().getMinY();\r\n        bx = playerBArboretumPane.getBoundsInParent().getMinX();\r\n        by = playerBArboretumPane.getBoundsInParent().getMinY();\r\n\r\n        DropShadow dropShadow = new DropShadow();\r\n        dropShadow.setRadius(5.0);\r\n        dropShadow.setOffsetX(3.0);\r\n        dropShadow.setOffsetY(3.0);\r\n        dropShadow.setColor(Color.color(0.4, 0.5, 0.5));\r\n        for (var i : root.getChildren()) {\r\n            i.setEffect(dropShadow);\r\n        }\r\n\r\n        Set<Node> newHighlight = new HashSet<>();\r\n        newHighlight.add(deckButton);\r\n        newHighlight.add(playerADiscardButton);\r\n        newHighlight.add(playerBDiscardButton);\r\n        highlightPane(newHighlight);\r\n\r\n        drawGame(gameState);\r\n    }\r\n\r\n    /**\r\n     * highlight the corresponding panes to show the current procedure of the game\r\n     *\r\n     * @param paneSet a set of pane waiting for highlighting\r\n     * @author Ziyao Jin\r\n     */\r\n    private void highlightPane(Set<Node> paneSet) {\r\n        DropShadow dropShadow = new DropShadow();\r\n        dropShadow.setRadius(5.0);\r\n        dropShadow.setOffsetX(3.0);\r\n        dropShadow.setOffsetY(3.0);\r\n        dropShadow.setColor(Color.color(0.4, 0.5, 0.5));\r\n\r\n        DropShadow highlight = new DropShadow();\r\n        highlight.setRadius(15.0);\r\n        highlight.setOffsetX(3.0);\r\n        highlight.setOffsetY(3.0);\r\n        highlight.setColor(Color.web(\"900021\"));\r\n\r\n        if (!highlightedPane.isEmpty()) {\r\n            for (var i : highlightedPane) i.setEffect(dropShadow);\r\n            highlightedPane.clear();\r\n        }\r\n        highlightedPane.addAll(paneSet);\r\n        for (var i : highlightedPane) i.setEffect(highlight);\r\n    }\r\n\r\n    /**\r\n     * Draw the current state of the game after each interaction\r\n     * First, clear the current board\r\n     * Second, draw the new board\r\n     * Finally, check canScore().\r\n     *\r\n     * @author Ziyao Jin\r\n     * @author Weiqiang PU\r\n     */\r\n    private void drawGame(String[][] gameState) {\r\n        //if (Arboretum.isStateValid(gameState)) {\r\n        // Clear previous content\r\n        playerAHandPane.getChildren().clear();\r\n        playerBHandPane.getChildren().clear();\r\n        playerAArboretumPane.getChildren().clear();\r\n        playerBArboretumPane.getChildren().clear();\r\n\r\n        if (gameState[0][2].length() > 1)\r\n            playerADiscardButton.setGraphic(new Card(gameState[0][2].substring(gameState[0][2].length() - 2)));\r\n        else playerADiscardButton.setGraphic(new Card(\"00\"));\r\n        if (gameState[0][4].length() > 1)\r\n            playerBDiscardButton.setGraphic(new Card(gameState[0][4].substring(gameState[0][4].length() - 2)));\r\n        else playerBDiscardButton.setGraphic(new Card(\"00\"));\r\n\r\n        // Hand A\r\n        String handAStr = gameState[1][1];\r\n        for (int i = 1; i < handAStr.length(); i += 2) {\r\n            DraggableCard newCard = new DraggableCard(handAStr.substring(i, i + 2));\r\n            playerAHandPane.getChildren().add(newCard);\r\n        }\r\n        // Hand B\r\n        String handBStr = gameState[1][2];\r\n        for (int i = 1; i < handBStr.length(); i += 2) {\r\n            if (haveAI) {\r\n                Card newCard = new Card(\"00\"); //this line uses when computer opponent\r\n                playerBHandPane.getChildren().add(newCard);\r\n            } else {\r\n                DraggableCard newCard = new DraggableCard(handBStr.substring(i, i + 2)); //this line uses when human player\r\n                playerBHandPane.getChildren().add(newCard);\r\n            }\r\n        }\r\n        // Arboretum A\r\n        String arboretumAStr = gameState[0][1];\r\n        drawArboretum(arboretumAStr, playerAArboretumPane);\r\n        // Arboretum B\r\n        String arboretumBStr = gameState[0][3];\r\n        drawArboretum(arboretumBStr, playerBArboretumPane);\r\n        //check whether match the condition to change round\r\n        switchRound();\r\n    }\r\n\r\n    /**\r\n     * Game mode selection interface\r\n     *\r\n     * @author Hanqin Liu\r\n     */\r\n    private void displayStart() {\r\n        Stage window = new Stage();\r\n        window.setTitle(\"Game Mode\");\r\n\r\n        window.initModality(Modality.APPLICATION_MODAL);\r\n        window.setMinWidth(300);\r\n        window.setMinHeight(150);\r\n\r\n        Button buttonPlayer = new Button(\"Player A vs. Player B\");\r\n        Button buttonAI = new Button(\"Player vs. AI\");\r\n        buttonPlayer.setOnAction(e -> window.close());\r\n        buttonAI.setOnAction(e -> {\r\n            window.close();\r\n            haveAI = true;\r\n        });\r\n\r\n        Label label = new Label();\r\n        VBox layout = new VBox(10);\r\n        layout.getChildren().addAll(label, buttonPlayer, buttonAI);\r\n        layout.setAlignment(Pos.CENTER);\r\n\r\n        Scene scene = new Scene(layout);\r\n        window.setScene(scene);\r\n        //Use showAndWait() to process the window first, while if not, the window in main cannot respond\r\n        window.showAndWait();\r\n    }\r\n\r\n    /**\r\n     * Display the ending and provide players with options.\r\n     *\r\n     * @param message Messages displayed in the window.\r\n     * @author Ziyao Jin\r\n     * @author Hanqin Liu\r\n     */\r\n    private void displayEnd(String message) {\r\n        Stage window = new Stage();\r\n        window.setTitle(\"Game End\");\r\n        window.initModality(Modality.APPLICATION_MODAL);\r\n        window.setMinWidth(300);\r\n        window.setMinHeight(160);\r\n\r\n        Button buttonQuit = new Button(\"Quit\");\r\n        buttonQuit.setOnAction(e -> {\r\n            window.close();\r\n            Stage stage = (Stage) playerAArboretumPane.getScene().getWindow();\r\n            stage.close();\r\n        });\r\n\r\n        Button buttonRestart = new Button(\"Restart\");\r\n        buttonRestart.setOnAction(e -> {\r\n            window.close();\r\n            Stage stage = (Stage) playerAArboretumPane.getScene().getWindow();\r\n            stage.close();\r\n            gameState = new String[][]{{\"A\", \"A\", \"A\", \"B\", \"B\"}, {\"a1a2a3a4a5a6a7a8b1b2b3b4b5b6b7b8c1c2c3c4c5c6c7c8d1d2d3d4d5d6d7d8j1j2j3j4j5j6j7j8m1m2m3m4m5m6m7m8\", \"A\", \"B\"}};\r\n            haveAI = false;\r\n            playerAArboretumPane = new GridPane();\r\n            playerBArboretumPane = new GridPane();\r\n            start(new Stage());\r\n        });\r\n\r\n        Label label = new Label(message);\r\n\r\n        VBox layout = new VBox(10);\r\n        layout.getChildren().addAll(label, buttonRestart, buttonQuit);\r\n        layout.setAlignment(Pos.CENTER);\r\n\r\n        Scene scene = new Scene(layout);\r\n        window.setScene(scene);\r\n        //Use showAndWait() to process the window first, while if not, the window in main cannot respond\r\n        window.showAndWait();\r\n    }\r\n\r\n\r\n    private void drawArboretum(String arboretumAStr, GridPane arboretumPane) {\r\n        arboretumPane.setTranslateX(0);\r\n        arboretumPane.setTranslateY(0);\r\n        String[][] gameState = new String[][]{\r\n                {\"A\", arboretumAStr, \"A\", \"B\", \"B\"},\r\n                {\"\", \"\", \"\"}};\r\n        var highlightSet = Arboretum.getAllValidPlacements(gameState, \"11\");\r\n        StringBuilder arboretumAStrBuilder = new StringBuilder(arboretumAStr);\r\n        for (var i : highlightSet) {\r\n            arboretumAStrBuilder.append(i);\r\n        }\r\n        arboretumAStr = arboretumAStrBuilder.toString();\r\n\r\n        int biggestN = 0, biggestS = 0, biggestW = 0, biggestE = 0;\r\n        for (int i = 1; i < arboretumAStr.length(); i += 8) {\r\n            String v = arboretumAStr.substring(i + 3, i + 5);\r\n            String h = arboretumAStr.substring(i + 6, i + 8);\r\n            if (arboretumAStr.charAt(i + 2) == 'N' && Integer.parseInt(v) > biggestN) biggestN = Integer.parseInt(v);\r\n            if (arboretumAStr.charAt(i + 2) == 'S' && Integer.parseInt(v) > biggestS) biggestS = Integer.parseInt(v);\r\n            if (arboretumAStr.charAt(i + 5) == 'W' && Integer.parseInt(h) > biggestW) biggestW = Integer.parseInt(h);\r\n            if (arboretumAStr.charAt(i + 5) == 'E' && Integer.parseInt(h) > biggestE) biggestE = Integer.parseInt(h);\r\n        }\r\n        for (int i = 1; i < arboretumAStr.length(); i += 8) {\r\n            int x = 0, y = 0;\r\n            String v = arboretumAStr.substring(i + 3, i + 5);\r\n            String h = arboretumAStr.substring(i + 6, i + 8);\r\n            String species = arboretumAStr.substring(i, i + 2);\r\n            if (arboretumAStr.charAt(i + 5) == 'W') x = biggestW - Integer.parseInt(h);\r\n            if (arboretumAStr.charAt(i + 5) == 'E') x = biggestW + 1 + Integer.parseInt(h);\r\n            if (arboretumAStr.charAt(i + 5) == 'C') x = biggestW + 1;\r\n            if (arboretumAStr.charAt(i + 2) == 'N') y = biggestN - Integer.parseInt(v);\r\n            if (arboretumAStr.charAt(i + 2) == 'S') y = biggestN + 1 + Integer.parseInt(v);\r\n            if (arboretumAStr.charAt(i + 2) == 'C') y = biggestN + 1;\r\n            if (species.equals(\"11\")) {\r\n                PositionCard newCard = new PositionCard(arboretumAStr.substring(i + 2, i + 5),\r\n                        arboretumAStr.substring(i + 5, i + 8));\r\n                newCard.setVisible(false);\r\n                arboretumPane.add(newCard, x, y);\r\n            } else {\r\n                Card newCard = new Card(species);\r\n                arboretumPane.add(newCard, x, y);\r\n            }\r\n        }\r\n        var xScale = (BOARD_WIDTH - WINDOW_XOFFSET * 3 - CARD_WIDTH * 9) / ((biggestW + 1 + biggestE) * CARD_WIDTH);\r\n        var yScale = (BOARD_HEIGHT - WINDOW_YOFFSET * 3 - CARD_HEIGHT) / ((biggestN + 1 + biggestS) * CARD_HEIGHT);\r\n        if (xScale < 1) arboretumPane.setScaleX(xScale);\r\n        if (yScale < 1) arboretumPane.setScaleY(yScale);\r\n        double xTrans, yTrans;\r\n        if (arboretumAStr.charAt(0) == 'A') {\r\n            xTrans = ax - arboretumPane.getBoundsInParent().getMinX();\r\n            yTrans = ay - arboretumPane.getBoundsInParent().getMinY();\r\n        } else {\r\n            xTrans = bx - arboretumPane.getBoundsInParent().getMinX();\r\n            yTrans = by - arboretumPane.getBoundsInParent().getMinY();\r\n        }\r\n        if (xScale < 1) arboretumPane.setTranslateX(xTrans);\r\n        if (yScale < 1) arboretumPane.setTranslateY(yTrans);\r\n    }\r\n\r\n    /**\r\n     * Find the nearest placeable card position\r\n     *\r\n     * @param x    coordinate\r\n     * @param y    coordinate\r\n     * @param pane desired pane\r\n     * @return the nearest card node\r\n     * @author Ziyao Jin\r\n     */\r\n    private PositionCard findNearestCardPosition(GridPane pane, double x, double y) {\r\n        double initial = Double.MAX_VALUE;\r\n        PositionCard nearestCard = null;\r\n        for (var i : pane.getChildren()) {\r\n            if (i.getClass() == PositionCard.class) {\r\n                var position = i.getLocalToSceneTransform().transform(\r\n                        i.getLayoutBounds().getCenterX(),\r\n                        i.getLayoutBounds().getCenterY()\r\n                );\r\n                var distance = sqrt((x - position.getX()) * (x - position.getX())\r\n                        + (y - position.getY()) * (y - position.getY()));\r\n                if (distance < initial) {\r\n                    initial = distance;\r\n                    nearestCard = (PositionCard) i;\r\n                }\r\n            }\r\n        }\r\n        return nearestCard;\r\n    }\r\n\r\n    /**\r\n     * Highlight the nearest placeable card position\r\n     *\r\n     * @param pane desired pane\r\n     * @param x    coordinate\r\n     * @param y    coordinate\r\n     * @author Ziyao Jin\r\n     */\r\n    private void highlightNearestCardPosition(GridPane pane, double x, double y) {\r\n        if (highlightedCard != null) {\r\n            highlightedCard.setVisible(false);\r\n            highlightedCard.setFill(Color.WHITE);\r\n        }\r\n        highlightedCard = findNearestCardPosition(pane, x, y);\r\n        highlightedCard.setFill(Color.web(\"82D8CF\"));\r\n        highlightedCard.setVisible(true);\r\n    }\r\n\r\n    /**\r\n     * Draw a random card from the deck.\r\n     * gameState[1] is the array of hidden state\r\n     * gameState[2] is the array of shared state\r\n     * Update game state: remove the drawn card from the deck, then add the drawn card into player's hand\r\n     *\r\n     * @author Weiqiang PU\r\n     */\r\n    private void drawFromDeck() {\r\n        ArrayList<String> cardList = new ArrayList<>(Arrays.asList(Arboretum.getValueFromHidden(gameState[1])[0]));\r\n        String drawnCard = cardList.get((int) (Math.random() * cardList.size())); //draw card randomly\r\n        StringBuilder temp = new StringBuilder(gameState[1][0]);\r\n        temp.delete(temp.indexOf(drawnCard), temp.indexOf(drawnCard) + 2); //delete the drawn card from the deck\r\n        gameState[1][0] = temp.toString();\r\n        addToHand(drawnCard);\r\n        drawCount++;\r\n        highlightPlace();\r\n        drawGame(gameState);\r\n    }\r\n\r\n    /**\r\n     * Draw the top card from the clicked discard.\r\n     * gameState[1] is the array of hidden state\r\n     * gameState[2] is the array of shared state\r\n     * Update game state: remove the drawn card from the clicked discard pile, then add the drawn card into player's hand\r\n     *\r\n     * @param drawDiscardControl to control draw from which discard pile\r\n     * @author Weiqiang PU\r\n     */\r\n    private void drawFromDiscard(int drawDiscardControl) {\r\n        String drawnCard = gameState[0][drawDiscardControl].substring(gameState[0][drawDiscardControl].length() - 2);\r\n        gameState[0][drawDiscardControl] = gameState[0][drawDiscardControl].substring(0, gameState[0][drawDiscardControl].length() - 2);\r\n        addToHand(drawnCard);\r\n        drawCount++;\r\n        highlightPlace();\r\n        drawGame(gameState);\r\n    }\r\n\r\n    private void highlightPlace() {\r\n        if (drawCount == 2) {\r\n            Set<Node> newHighlight = new HashSet<>();\r\n            switch (gameState[0][0]) {\r\n                case \"A\" -> {\r\n                    newHighlight.add(playerAHandPane);\r\n                    newHighlight.add(playerAArboretumPane);\r\n                }\r\n                case \"B\" -> {\r\n                    newHighlight.add(playerBHandPane);\r\n                    newHighlight.add(playerBArboretumPane);\r\n                }\r\n            }\r\n            highlightPane(newHighlight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * add card to hand and alphabetize the hand\r\n     *\r\n     * @param drawnCard card needed to add\r\n     * @author Weiqiang PU\r\n     */\r\n    private void addToHand(String drawnCard) {\r\n        int turnID = 0;\r\n        String playerID = \"\";\r\n        switch (gameState[0][0]) {\r\n            case \"A\" -> {\r\n                turnID = 1;\r\n                playerID = \"A\";\r\n            }\r\n            case \"B\" -> {\r\n                turnID = 2;\r\n                playerID = \"B\";\r\n            }\r\n        }\r\n        ArrayList<String> handStrList = new ArrayList<>();\r\n        for (int i = 1; i < gameState[1][turnID].length(); i += 2) {\r\n            handStrList.add(gameState[1][turnID].substring(i, i + 2));\r\n        }\r\n        handStrList.add(drawnCard);\r\n        Collections.sort(handStrList);\r\n        StringBuilder tempHand = new StringBuilder(playerID);\r\n        for (String i : handStrList) {\r\n            tempHand.append(i);\r\n        }\r\n        gameState[1][turnID] = tempHand.toString();\r\n    }\r\n\r\n    /**\r\n     * Discard a selected card from the hand.\r\n     * gameState[1] is the array of hidden state\r\n     * gameState[2] is the array of shared state\r\n     * Update game state: remove the discard from the hand, then add the card into player's discard pile\r\n     *\r\n     * @param species discard\r\n     * @author Weiqiang PU\r\n     * @author Ziyao Jin\r\n     * @author Hanqin Liu\r\n     */\r\n    private void discard(String species) {\r\n        switch (gameState[0][0]) {\r\n            case \"A\" -> {\r\n                if (gameState[1][1].contains(species)) {\r\n                    gameState[0][2] += species;\r\n                    removeFromHand(species, \"A\");\r\n                    haveDiscarded = true;\r\n                }\r\n            }\r\n            case \"B\" -> {\r\n                if (gameState[1][2].contains(species)) {\r\n                    gameState[0][4] += species;\r\n                    removeFromHand(species, \"B\");\r\n                    haveDiscarded = true;\r\n                }\r\n            }\r\n        }\r\n        Set<Node> newHighlight = new HashSet<>();\r\n        newHighlight.add(deckButton);\r\n        newHighlight.add(playerADiscardButton);\r\n        newHighlight.add(playerBDiscardButton);\r\n        highlightPane(newHighlight);\r\n        drawGame(gameState);\r\n\r\n        //check whether match the end condition\r\n        if (gameState[1][0].length() == 0) {\r\n            displayEnd(\"Player A: \" + Arboretum.getTotalViablePathScore(gameState, 'A') + \"\\n\" + \"Player B: \"\r\n                    + Arboretum.getTotalViablePathScore(gameState, 'B') + \"\\n\" + Arboretum.getWinner(gameState));\r\n        }\r\n    }\r\n\r\n    private class DraggableCard extends Card {\r\n        private double mouseX;\r\n        private double mouseY;\r\n\r\n        /**\r\n         * a draggable card constructor\r\n         *\r\n         * @param species card value and species\r\n         * @author Ziyao Jin\r\n         * @author Weiqiang PU\r\n         * @author Hanqin Liu\r\n         */\r\n        DraggableCard(String species) {\r\n            super(species);\r\n            setOnMousePressed(event -> {\r\n                mouseX = event.getSceneX();\r\n                mouseY = event.getSceneY();\r\n            });\r\n            setOnMouseDragged(event -> {\r\n                if (!havePlaced && drawCount == 2) {\r\n                    switch (gameState[0][0]) {\r\n                        case \"A\" -> {\r\n                            if (getParent() == playerAHandPane) highlightNearestCardPosition(playerAArboretumPane,\r\n                                    event.getSceneX(), event.getSceneY());\r\n                        }\r\n                        case \"B\" -> {\r\n                            if (getParent() == playerBHandPane) highlightNearestCardPosition(playerBArboretumPane,\r\n                                    event.getSceneX(), event.getSceneY());\r\n                        }\r\n                    }\r\n                }\r\n                setTranslateX(event.getSceneX() - mouseX);\r\n                setTranslateY(event.getSceneY() - mouseY);\r\n            });\r\n            //putting the card in the nearest placeable position or discard pile when releasing mouse and update game state\r\n            setOnMouseReleased(event -> {\r\n                if (!havePlaced && drawCount == 2) {\r\n                    String newPlacement = species + highlightedCard.getPosV() + highlightedCard.getPosH();\r\n                    try {\r\n                        if (gameState[0][0].equals(\"A\") && getParent() == playerAHandPane) {\r\n                            Point2D pos = playerAArboretumPane.getLocalToSceneTransform().inverseTransform(event.getSceneX(), event.getSceneY());\r\n                            if (playerAArboretumPane.contains(pos)) {\r\n                                playerAHandPane.getChildren().remove(this);\r\n                                gameState[0][1] += newPlacement;\r\n                                removeFromHand(species, \"A\");\r\n                                havePlaced = true;\r\n                                Set<Node> newHighlight = new HashSet<>();\r\n                                newHighlight.add(playerAHandPane);\r\n                                newHighlight.add(playerADiscardButton);\r\n                                highlightPane(newHighlight);\r\n                            }\r\n                        } else if (gameState[0][0].equals(\"B\") && getParent() == playerBHandPane) {\r\n                            Point2D pos = playerBArboretumPane.getLocalToSceneTransform().inverseTransform(event.getSceneX(), event.getSceneY());\r\n                            if (playerBArboretumPane.contains(pos)) {\r\n                                playerBHandPane.getChildren().remove(this);\r\n                                gameState[0][3] += newPlacement;\r\n                                removeFromHand(species, \"B\");\r\n                                havePlaced = true;\r\n                                Set<Node> newHighlight = new HashSet<>();\r\n                                newHighlight.add(playerBHandPane);\r\n                                newHighlight.add(playerBDiscardButton);\r\n                                highlightPane(newHighlight);\r\n                            }\r\n                        }\r\n                    } catch (NonInvertibleTransformException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                } else {\r\n                    try {\r\n                        if (!haveDiscarded & drawCount == 2) {\r\n                            if (Objects.equals(gameState[0][0], \"A\")) {\r\n                                Point2D pos = playerADiscardButton.getLocalToSceneTransform().inverseTransform(\r\n                                        event.getSceneX(), event.getSceneY());\r\n                                if (playerADiscardButton.contains(pos)) discard(species);\r\n                            } else {\r\n                                Point2D pos = playerBDiscardButton.getLocalToSceneTransform().inverseTransform(\r\n                                        event.getSceneX(), event.getSceneY());\r\n                                if (playerBDiscardButton.contains(pos)) discard(species);\r\n                            }\r\n                        }\r\n                    } catch (NonInvertibleTransformException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n                drawGame(gameState);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * remove card from hand, update and alphabetize the hand string\r\n     *\r\n     * @param species string of card\r\n     * @param player  the sign of which player\r\n     * @author Ziyao Jin\r\n     */\r\n    private void removeFromHand(String species, String player) {\r\n        int turn;\r\n        if (Objects.equals(player, \"A\")) {\r\n            turn = 1;\r\n        } else {\r\n            turn = 2;\r\n        }\r\n        ArrayList<String> handStrList = new ArrayList<>();\r\n        for (int i = 1; i < gameState[1][turn].length(); i += 2) {\r\n            handStrList.add(gameState[1][turn].substring(i, i + 2));\r\n        }\r\n        handStrList.remove(species);\r\n        Collections.sort(handStrList);\r\n        StringBuilder updatedStr = new StringBuilder(player);\r\n        for (var i : handStrList) {\r\n            updatedStr.append(i);\r\n        }\r\n        gameState[1][turn] = updatedStr.toString();\r\n        drawGame(gameState);\r\n    }\r\n\r\n    /**\r\n     * Switch the round and initialize the state of each round\r\n     *\r\n     * @author Weiqiang PU\r\n     */\r\n    private void switchRound() {\r\n        if (havePlaced && haveDiscarded && drawCount == 2) {\r\n            havePlaced = false;\r\n            haveDiscarded = false;\r\n            drawCount = 0;\r\n            switch (gameState[0][0]) {\r\n                case \"A\" -> {\r\n                    gameState[0][0] = \"B\";\r\n                    if (haveAI) computerOpponentMove();\r\n                }\r\n                case \"B\" -> gameState[0][0] = \"A\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * generate the computer opponent's move\r\n     *\r\n     * @author Weiqiang PU\r\n     */\r\n    private void computerOpponentMove() {\r\n        if (gameState[1][0].length() != 0) {\r\n            for (int a = 0; a < 2; a++) {\r\n                String drawString = Arboretum.advancedAiLocation(gameState);\r\n                if (Objects.equals(drawString, \"D\")) drawFromDeck();\r\n                else {\r\n                    if (gameState[0][2].contains(drawString))\r\n                        drawFromDiscard(2);\r\n                    else if (gameState[0][4].contains(drawString))\r\n                        drawFromDiscard(4);\r\n                }\r\n            }\r\n            String[] moveString = Arboretum.advancedAiMove(gameState);\r\n            removeFromHand(moveString[0].substring(0, 2), \"B\");\r\n            gameState[0][3] = gameState[0][3] + moveString[0];\r\n            havePlaced = true;\r\n            discard(moveString[1]);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/comp1110/ass2/gui/Game.java b/src/comp1110/ass2/gui/Game.java
--- a/src/comp1110/ass2/gui/Game.java	(revision 1340d7beb8d0680c6e7028fe8abb757d31343e9a)
+++ b/src/comp1110/ass2/gui/Game.java	(date 1652944292784)
@@ -282,7 +282,7 @@
         window.setTitle("Game Mode");
 
         window.initModality(Modality.APPLICATION_MODAL);
-        window.setMinWidth(300);
+        window.setWidth(300);
         window.setMinHeight(150);
 
         Button buttonPlayer = new Button("Player A vs. Player B");
@@ -590,7 +590,7 @@
         private double mouseY;
 
         /**
-         * a draggable card constructor
+         * a draggable card constructor with dragged, released event
          *
          * @param species card value and species
          * @author Ziyao Jin
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_17\" project-jdk-name=\"17\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n  <component name=\"SwUserDefinedSpecifications\">\r\n    <option name=\"specTypeByUrl\">\r\n      <map />\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 1340d7beb8d0680c6e7028fe8abb757d31343e9a)
+++ b/.idea/misc.xml	(date 1652924528875)
@@ -3,9 +3,4 @@
   <component name="ProjectRootManager" version="2" languageLevel="JDK_17" project-jdk-name="17" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
-  <component name="SwUserDefinedSpecifications">
-    <option name="specTypeByUrl">
-      <map />
-    </option>
-  </component>
 </project>
\ No newline at end of file
